<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RecomandƒÉrile Tale - Spotify SDR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            animation: slideUp 0.6s ease-out;
        }
        
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            background: linear-gradient(135deg, #1db954, #1ed760);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 700;
        }
        
        .progress-section {
            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-left: 5px solid #667eea;
        }
        
        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e1e5e9;
            border-radius: 6px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #1db954, #1ed760);
            border-radius: 6px;
            transition: width 0.5s ease;
            width: 0%;
        }
        
        .tracks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .track-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #1db954;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .track-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
        }
        
        .track-name {
            font-weight: 700;
            font-size: 18px;
            color: #333;
            margin-bottom: 8px;
        }
        
        .track-artist {
            color: #667eea;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 15px;
        }
        
        .track-details {
            font-size: 13px;
            color: #666;
            background: rgba(255,255,255,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .track-actions {
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .like-btn {
            background: linear-gradient(135deg, #e91e63, #ad1457);
            color: white;
            box-shadow: 0 5px 15px rgba(233, 30, 99, 0.3);
        }
        
        .like-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(233, 30, 99, 0.4);
        }
        
        .dislike-btn {
            background: linear-gradient(135deg, #ff5722, #d84315);
            color: white;
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.3);
        }
        
        .dislike-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 87, 34, 0.4);
        }
        
        .refresh-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        .loading {
            text-align: center;
            color: #667eea;
            font-size: 16px;
            font-weight: 600;
            padding: 40px;
        }
        
        /* Animations */
        .track-card.liked-animation {
            animation: likeAnimation 1.2s ease-out forwards;
        }
        
        .track-card.disliked-animation {
            animation: dislikeAnimation 1.2s ease-out forwards;
        }
        
        @keyframes likeAnimation {
            0% { transform: scale(1) rotate(0deg); }
            20% { transform: scale(1.1) rotate(5deg); }
            40% { transform: scale(1.05) rotate(-3deg); }
            60% { transform: scale(1.08) rotate(2deg); }
            80% { transform: scale(0.95) rotate(0deg); opacity: 1; }
            100% { transform: scale(0) rotate(0deg); opacity: 0; }
        }
        
        @keyframes dislikeAnimation {
            0% { transform: translateX(0) rotate(0deg); opacity: 1; }
            25% { transform: translateX(-20px) rotate(-5deg); }
            50% { transform: translateX(20px) rotate(5deg); }
            75% { transform: translateX(-10px) rotate(-2deg); opacity: 0.5; }
            100% { transform: translateX(100vw) rotate(10deg); opacity: 0; }
        }
        
        .floating-heart {
            position: fixed;
            font-size: 24px;
            color: #e91e63;
            pointer-events: none;
            z-index: 1000;
            animation: floatHeart 2s ease-out forwards;
        }
        
        @keyframes floatHeart {
            0% { transform: translateY(0) scale(0); opacity: 0; }
            20% { transform: translateY(-20px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-100px) scale(0.8); opacity: 0; }
        }
        
        .floating-dislike {
            position: fixed;
            font-size: 24px;
            color: #ff5722;
            pointer-events: none;
            z-index: 1000;
            animation: floatDislike 2s ease-out forwards;
        }
        
        @keyframes floatDislike {
            0% { transform: translateY(0) scale(0) rotate(0deg); opacity: 0; }
            20% { transform: translateY(-20px) scale(1.2) rotate(-10deg); opacity: 1; }
            100% { transform: translateY(-100px) scale(0.8) rotate(-20deg); opacity: 0; }
        }
        
        /* Similar tracks notification styles */
        .similar-tracks-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            max-width: 350px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: slideInRight 0.5s ease-out;
        }
        
        .notification-content h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
        }
        
        .similar-tracks-list {
            margin: 10px 0;
        }
        
        .similar-track-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(74, 144, 226, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(74, 144, 226, 0.2);
        }
        
        .similar-track-item:hover {
            background: rgba(74, 144, 226, 0.2);
            transform: translateX(5px);
        }
        
        .similar-track-item strong {
            color: #333;
            font-size: 14px;
        }
        
        .similar-track-item small {
            color: #666;
            font-size: 12px;
        }
        
        .close-notification {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-notification:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4a90e2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Modal styles pentru piese similare */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease-out;
        }
        
        .modal-overlay.show {
            display: flex;
        }
        
        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: modalSlideIn 0.4s ease-out;
        }
        
        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease;
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-track-card {
            margin: 0;
            border: none;
            box-shadow: none;
            background: transparent;
        }
        
        .modal-track-card .track-actions {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .modal-track-card .action-btn {
            padding: 12px 24px;
            font-size: 16px;
            min-width: 140px;
        }
        
        .track-preview {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            font-style: italic;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes modalSlideIn {
            from {
                transform: scale(0.7) translateY(-50px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes modalSlideOut {
            from {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
            to {
                transform: scale(0.7) translateY(-50px);
                opacity: 0;
            }
        }
        
        .modal-content.closing {
            animation: modalSlideOut 0.3s ease-in forwards;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ RecomandƒÉrile Tale</h1>
        
        <div class="progress-section">
            <h3>üéØ Progresul Profilului TƒÉu</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressMessage">ApreciazƒÉ piese pentru recomandƒÉri mai bune!</p>
        </div>
        
        <button class="refresh-btn" onclick="loadNewRecommendations()">
            üîÑ RecomandƒÉri Noi
        </button>
        
        <div id="loading" class="loading" style="display: none;">
            Se √ÆncarcƒÉ recomandƒÉrile...
        </div>
        
        <div id="tracksContainer" class="tracks-grid">
            <!-- Tracks will be loaded here -->
        </div>
    </div>

    <!-- Modal pentru piese similare -->
    <div id="similarTrackModal" class="modal-overlay" onclick="closeSimilarTrackModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3>üéµ PiesƒÉ SimilarƒÉ</h3>
                <button class="modal-close" onclick="closeSimilarTrackModal()">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="modalTrackCard" class="track-card modal-track-card">
                    <!-- Con»õinutul va fi generat dinamic -->
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('üéµ Recommendations page loaded - Main version with fixes');
        
        let currentUser = null;
        let currentRecommendations = [];
        let likedCount = 0;
        let recommendationBuffer = [];
        let currentOffset = 0;
        
        // Check authentication on page load
        window.addEventListener('load', async function() {
            console.log('Page loaded, checking authentication...');
            try {
                const response = await fetch('/api/auth/check');
                if (response.ok) {
                    const result = await response.json();
                    if (result.authenticated) {
                        currentUser = result;
                        console.log('User authenticated:', currentUser);
                        await loadUserStats();
                        await loadRecommendations();
                    } else {
                        console.log('User not authenticated, loading test recommendations');
                        await loadTestRecommendations();
                    }
                } else {
                    console.log('Auth check failed, loading test recommendations');
                    await loadTestRecommendations();
                }
            } catch (error) {
                console.error('Error checking authentication:', error);
                await loadTestRecommendations();
            }
        });
        
        async function loadUserStats() {
            try {
                const response = await fetch(`/api/user/${currentUser.user_id}/stats`);
                if (response.ok) {
                    const data = await response.json();
                    likedCount = data.liked_tracks_count || 0;
                    updateProgressIndicator(likedCount);
                }
            } catch (error) {
                console.error('Error loading user stats:', error);
            }
        }
        
        function updateProgressIndicator(count) {
            const progressFill = document.getElementById('progressFill');
            const progressMessage = document.getElementById('progressMessage');
            
            const maxTracks = 25;
            const percentage = Math.min((count / maxTracks) * 100, 100);
            
            progressFill.style.width = percentage + '%';
            
            if (count === 0) {
                progressMessage.textContent = 'ApreciazƒÉ cel pu»õin 25 de piese pentru recomandƒÉri bazate pe gusturile tale!';
            } else if (count < 25) {
                progressMessage.textContent = `Excelent! √éncƒÉ ${25 - count} piese »ôi vei primi recomandƒÉri »ôi mai precise.`;
            } else {
                progressMessage.textContent = 'Perfect! Acum prime»ôti recomandƒÉri bazate pe gusturile tale muzicale!';
            }
        }
        
        async function loadRecommendations(forceRefresh = false) {
            console.log('Loading recommendations...');
            const loading = document.getElementById('loading');
            const container = document.getElementById('tracksContainer');
            
            loading.style.display = 'block';
            container.innerHTML = '';
            
            try {
                // Get user stats to determine recommendation type
                const statsResponse = await fetch(`/api/user/${currentUser.user_id}/stats`);
                const stats = await statsResponse.json();
                const likedCount = stats.liked_tracks_count || 0;
                
                let endpoint;
                if (likedCount < 10) {
                    endpoint = `/api/user/${currentUser.user_id}/recommendations/knowledge-based`;
                } else if (likedCount < 25) {
                    endpoint = `/api/user/${currentUser.user_id}/recommendations/mixed`;
                } else {
                    endpoint = `/api/user/${currentUser.user_id}/recommendations/content-based`;
                }
                
                // Add offset for variety and timestamp for fresh recommendations
                const timestamp = Date.now();
                if (forceRefresh) {
                    currentOffset += 10; // Move to next batch
                }
                endpoint += `?refresh=${timestamp}&offset=${currentOffset}`;
                
                console.log('Fetching from endpoint:', endpoint);
                const response = await fetch(endpoint);
                
                if (response.ok) {
                    const data = await response.json();
                    const newRecommendations = data.recommendations || [];
                    console.log('Loaded recommendations:', newRecommendations.length);
                    
                    if (forceRefresh) {
                        // Replace all recommendations
                        currentRecommendations = newRecommendations;
                        recommendationBuffer = [];
                    } else {
                        // Add to current recommendations
                        currentRecommendations = newRecommendations;
                        // Load extra recommendations for buffer
                        await loadRecommendationBuffer();
                    }
                    
                    displayRecommendations(currentRecommendations);
                } else {
                    console.error('Failed to load recommendations:', response.status);
                    container.innerHTML = '<p style="text-align: center; color: #666;">Nu s-au putut √ÆncƒÉrca recomandƒÉrile. √éncearcƒÉ din nou.</p>';
                }
            } catch (error) {
                console.error('Error loading recommendations:', error);
                container.innerHTML = '<p style="text-align: center; color: #dc3545;">Eroare de conexiune. √éncearcƒÉ din nou.</p>';
            }
            
            loading.style.display = 'none';
        }
        
        async function loadRecommendationBuffer() {
            if (!currentUser) return;
            
            try {
                // Load additional recommendations for the buffer
                const statsResponse = await fetch(`/api/user/${currentUser.user_id}/stats`);
                const stats = await statsResponse.json();
                const likedCount = stats.liked_tracks_count || 0;
                
                let endpoint;
                if (likedCount < 10) {
                    endpoint = `/api/user/${currentUser.user_id}/recommendations/knowledge-based`;
                } else if (likedCount < 25) {
                    endpoint = `/api/user/${currentUser.user_id}/recommendations/mixed`;
                } else {
                    endpoint = `/api/user/${currentUser.user_id}/recommendations/content-based`;
                }
                
                // Get next batch for buffer
                const bufferOffset = currentOffset + 10;
                endpoint += `?refresh=${Date.now()}&offset=${bufferOffset}`;
                
                const response = await fetch(endpoint);
                if (response.ok) {
                    const data = await response.json();
                    recommendationBuffer = data.recommendations || [];
                    console.log('Loaded buffer recommendations:', recommendationBuffer.length);
                }
            } catch (error) {
                console.error('Error loading buffer recommendations:', error);
            }
        }
        
        function displayRecommendations(tracks) {
            const container = document.getElementById('tracksContainer');
            
            if (!tracks || tracks.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">Nu s-au gƒÉsit recomandƒÉri.</p>';
                return;
            }
            
            let html = '';
            tracks.forEach((track, index) => {
                // Trimite interac»õiunea de vizualizare cƒÉtre Recombee
                if (currentUser && track.recomm_id) {
                    sendTrackView(track.track_id, track.recomm_id);
                }
                
                html += `
                    <div class="track-card" data-track-id="${track.track_id}" data-recomm-id="${track.recomm_id || ''}">
                        <div class="track-name">${track.track_name}</div>
                        <div class="track-artist">üé§ ${track.artists}</div>
                        <div class="track-details">
                            üéº Gen: ${track.track_genre || 'N/A'} | 
                            ‚ö° Energie: ${(track.energy || 0).toFixed(2)} | 
                            üíÉ Dansabilitate: ${(track.danceability || 0).toFixed(2)} | 
                            üìà Popularitate: ${track.popularity || 'N/A'}
                            ${track.source_label ? '<br>üìä ' + track.source_label : ''}
                        </div>
                        <div class="track-actions">
                            <button class="action-btn like-btn" onclick="likeTrack('${track.track_id}')">
                                ‚ù§Ô∏è √émi place
                            </button>
                            <button class="action-btn dislike-btn" onclick="dislikeTrack('${track.track_id}')">
                                üëé Nu √Æmi place
                            </button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            console.log('Displayed', tracks.length, 'tracks');
        }
        
        async function sendTrackView(trackId, recommId) {
            if (!currentUser) return;
            
            try {
                await fetch(`/api/user/${currentUser.user_id}/interaction`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        track_id: trackId,
                        interaction_type: 'listen',
                        recomm_id: recommId,
                        metadata: {
                            duration: 30,  // Durata implicitƒÉ de vizualizare
                            context: 'recommendations_page'
                        }
                    })
                });
                console.log('üìä Track view sent to Recombee:', trackId, 'recommId:', recommId);
            } catch (error) {
                console.error('Error sending track view:', error);
            }
        }
        
        async function likeTrack(trackId) {
            console.log('‚ù§Ô∏è LIKE button clicked for track:', trackId);
            
            const trackCard = document.querySelector(`[data-track-id="${trackId}"]`);
            if (!trackCard) {
                console.error('Track card not found for:', trackId);
                return;
            }
            
            // Disable buttons immediately
            const buttons = trackCard.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = true);
            
            // If no user (test mode), just show animation
            if (!currentUser) {
                console.log('Test mode - showing animation only');
                showLikeAnimation(trackCard);
                
                setTimeout(async () => {
                    trackCard.remove();
                    
                    // Try to add a new track from buffer
                    await addNewTrackFromBuffer();
                    
                    // Check if no more tracks
                    const remainingTracks = document.querySelectorAll('.track-card');
                    if (remainingTracks.length === 0) {
                        document.getElementById('tracksContainer').innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #666;">
                                <h3>üéâ Ai apreciat toate recomandƒÉrile test!</h3>
                                <p>ApasƒÉ "RecomandƒÉri Noi" pentru mai multe sugestii sau <a href="/login">autentificƒÉ-te</a> pentru recomandƒÉri personalizate.</p>
                            </div>
                        `;
                    }
                }, 1200);
                return;
            }
            
            try {
                console.log('Sending like request to API...');
                
                // Ob»õine recomm_id din card
                const recommId = trackCard.getAttribute('data-recomm-id');
                
                const response = await fetch(`/api/user/${currentUser.user_id}/interaction`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        track_id: trackId,
                        interaction_type: 'like',
                        recomm_id: recommId,  // Trimite ID-ul recomandƒÉrii pentru tracking
                        metadata: {
                            context: 'recommendations_page',
                            action: 'like_button'
                        }
                    })
                });
                
                console.log('API response status:', response.status);
                
                if (response.ok) {
                    console.log('‚úÖ Like successful!');
                    
                    // Show animation
                    showLikeAnimation(trackCard);
                    
                    // Update progress
                    likedCount++;
                    updateProgressIndicator(likedCount);
                    
                    // Show similar tracks notification
                    showSimilarTracksNotification(trackId);
                    
                    // Remove track after animation
                    setTimeout(async () => {
                        trackCard.remove();
                        
                        // Try to add a new track from buffer
                        await addNewTrackFromBuffer();
                        
                        // Check if no more tracks
                        const remainingTracks = document.querySelectorAll('.track-card');
                        if (remainingTracks.length === 0) {
                            document.getElementById('tracksContainer').innerHTML = `
                                <div style="text-align: center; padding: 40px; color: #666;">
                                    <h3>üéâ Ai apreciat toate recomandƒÉrile!</h3>
                                    <p>ApasƒÉ "RecomandƒÉri Noi" pentru mai multe sugestii.</p>
                                </div>
                            `;
                        }
                    }, 1200);
                    
                } else {
                    console.error('Like request failed:', response.status);
                    // Re-enable buttons on error
                    buttons.forEach(btn => btn.disabled = false);
                    alert('Eroare la adƒÉugarea la favorite.');
                }
            } catch (error) {
                console.error('Error in likeTrack:', error);
                // Re-enable buttons on error
                buttons.forEach(btn => btn.disabled = false);
                alert('Eroare de conexiune.');
            }
        }
        
        async function dislikeTrack(trackId) {
            console.log('üëé DISLIKE button clicked for track:', trackId);
            
            const trackCard = document.querySelector(`[data-track-id="${trackId}"]`);
            if (!trackCard) {
                console.error('Track card not found for:', trackId);
                return;
            }
            
            // Disable buttons immediately
            const buttons = trackCard.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = true);
            
            // If no user (test mode), just show animation
            if (!currentUser) {
                console.log('Test mode - showing animation only');
                showDislikeAnimation(trackCard);
                
                setTimeout(async () => {
                    trackCard.remove();
                    
                    // Try to add a new track from buffer
                    await addNewTrackFromBuffer();
                    
                    // Check if no more tracks
                    const remainingTracks = document.querySelectorAll('.track-card');
                    if (remainingTracks.length === 0) {
                        document.getElementById('tracksContainer').innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #666;">
                                <h3>ü§î Ai evaluat toate recomandƒÉrile test!</h3>
                                <p>ApasƒÉ "RecomandƒÉri Noi" pentru mai multe sugestii sau <a href="/login">autentificƒÉ-te</a> pentru recomandƒÉri personalizate.</p>
                            </div>
                        `;
                    }
                }, 1200);
                return;
            }
            
            try {
                console.log('Sending dislike request to API...');
                
                // Ob»õine recomm_id din card
                const recommId = trackCard.getAttribute('data-recomm-id');
                
                const response = await fetch(`/api/user/${currentUser.user_id}/interaction`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        track_id: trackId,
                        interaction_type: 'dislike',
                        recomm_id: recommId,  // Trimite ID-ul recomandƒÉrii pentru tracking
                        metadata: {
                            context: 'recommendations_page',
                            action: 'dislike_button'
                        }
                    })
                });
                
                console.log('API response status:', response.status);
                
                if (response.ok) {
                    console.log('‚úÖ Dislike successful!');
                    
                    // Show animation
                    showDislikeAnimation(trackCard);
                    
                    // Remove track after animation
                    setTimeout(async () => {
                        trackCard.remove();
                        
                        // Try to add a new track from buffer
                        await addNewTrackFromBuffer();
                        
                        // Check if no more tracks
                        const remainingTracks = document.querySelectorAll('.track-card');
                        if (remainingTracks.length === 0) {
                            document.getElementById('tracksContainer').innerHTML = `
                                <div style="text-align: center; padding: 40px; color: #666;">
                                    <h3>ü§î Ai evaluat toate recomandƒÉrile!</h3>
                                    <p>ApasƒÉ "RecomandƒÉri Noi" pentru mai multe sugestii.</p>
                                </div>
                            `;
                        }
                    }, 1200);
                    
                } else {
                    console.error('Dislike request failed:', response.status);
                    // Re-enable buttons on error
                    buttons.forEach(btn => btn.disabled = false);
                    alert('Eroare la marcarea ca neapreciat.');
                }
            } catch (error) {
                console.error('Error in dislikeTrack:', error);
                // Re-enable buttons on error
                buttons.forEach(btn => btn.disabled = false);
                alert('Eroare de conexiune.');
            }
        }
        
        function showLikeAnimation(trackCard) {
            console.log('üé≠ Showing like animation');
            trackCard.classList.add('liked-animation');
            
            // Create floating hearts
            const rect = trackCard.getBoundingClientRect();
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createFloatingHeart(rect.left + rect.width/2, rect.top + rect.height/2);
                }, i * 200);
            }
        }
        
        function showDislikeAnimation(trackCard) {
            console.log('üé≠ Showing dislike animation');
            trackCard.classList.add('disliked-animation');
            
            // Create floating thumbs down
            const rect = trackCard.getBoundingClientRect();
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    createFloatingDislike(rect.left + rect.width/2, rect.top + rect.height/2);
                }, i * 300);
            }
        }
        
        function createFloatingHeart(x, y) {
            const heart = document.createElement('div');
            heart.className = 'floating-heart';
            heart.innerHTML = '‚ù§Ô∏è';
            heart.style.left = (x + (Math.random() - 0.5) * 100) + 'px';
            heart.style.top = y + 'px';
            
            document.body.appendChild(heart);
            
            setTimeout(() => {
                heart.remove();
            }, 2000);
        }
        
        function createFloatingDislike(x, y) {
            const dislike = document.createElement('div');
            dislike.className = 'floating-dislike';
            dislike.innerHTML = 'üëé';
            dislike.style.left = (x + (Math.random() - 0.5) * 80) + 'px';
            dislike.style.top = y + 'px';
            
            document.body.appendChild(dislike);
            
            setTimeout(() => {
                dislike.remove();
            }, 2000);
        }
        
        async function loadTestRecommendations(forceRefresh = false) {
            console.log('Loading test recommendations...');
            const loading = document.getElementById('loading');
            const container = document.getElementById('tracksContainer');
            
            loading.style.display = 'block';
            container.innerHTML = '';
            
            try {
                if (forceRefresh) {
                    currentOffset += 10; // Move to next batch
                }
                
                console.log('Fetching test recommendations with offset:', currentOffset);
                const response = await fetch(`/api/test-recommendations?offset=${currentOffset}`);
                
                if (response.ok) {
                    const data = await response.json();
                    const newRecommendations = data.recommendations || [];
                    console.log('Loaded test recommendations:', newRecommendations.length);
                    
                    if (forceRefresh) {
                        // Replace all recommendations
                        currentRecommendations = newRecommendations;
                        recommendationBuffer = [];
                    } else {
                        // Initial load
                        currentRecommendations = newRecommendations;
                        // Load buffer
                        await loadTestRecommendationBuffer();
                    }
                    
                    displayRecommendations(currentRecommendations);
                    
                    // Update progress message for test mode
                    document.getElementById('progressMessage').textContent = 'Mod test - AutentificƒÉ-te pentru recomandƒÉri personalizate!';
                } else {
                    console.error('Failed to load test recommendations:', response.status);
                    container.innerHTML = '<p style="text-align: center; color: #666;">Nu s-au putut √ÆncƒÉrca recomandƒÉrile test. √éncearcƒÉ din nou.</p>';
                }
            } catch (error) {
                console.error('Error loading test recommendations:', error);
                container.innerHTML = '<p style="text-align: center; color: #dc3545;">Eroare de conexiune. √éncearcƒÉ din nou.</p>';
            }
            
            loading.style.display = 'none';
        }
        
        async function loadTestRecommendationBuffer() {
            try {
                // Load additional test recommendations for the buffer
                const bufferOffset = currentOffset + 10;
                console.log('Loading test buffer with offset:', bufferOffset);
                
                const response = await fetch(`/api/test-recommendations?offset=${bufferOffset}`);
                if (response.ok) {
                    const data = await response.json();
                    recommendationBuffer = data.recommendations || [];
                    console.log('Loaded test buffer recommendations:', recommendationBuffer.length);
                }
            } catch (error) {
                console.error('Error loading test buffer recommendations:', error);
            }
        }

        async function addNewTrackFromBuffer() {
            console.log('Adding new track from buffer...');
            
            if (recommendationBuffer.length > 0) {
                // Get next track from buffer
                const newTrack = recommendationBuffer.shift();
                console.log('Adding track from buffer:', newTrack.track_name);
                
                // Add it to current recommendations
                currentRecommendations.push(newTrack);
                
                // Create and add the new track card
                const container = document.getElementById('tracksContainer');
                const newTrackHtml = `
                    <div class="track-card" data-track-id="${newTrack.track_id}" style="opacity: 0; transform: translateY(20px);">
                        <div class="track-name">${newTrack.track_name}</div>
                        <div class="track-artist">üé§ ${newTrack.artists}</div>
                        <div class="track-details">
                            üéº Gen: ${newTrack.track_genre || 'N/A'} | 
                            ‚ö° Energie: ${(newTrack.energy || 0).toFixed(2)} | 
                            üíÉ Dansabilitate: ${(newTrack.danceability || 0).toFixed(2)} | 
                            üìà Popularitate: ${newTrack.popularity || 'N/A'}
                        </div>
                        <div class="track-actions">
                            <button class="action-btn like-btn" onclick="likeTrack('${newTrack.track_id}')">
                                ‚ù§Ô∏è √émi place
                            </button>
                            <button class="action-btn dislike-btn" onclick="dislikeTrack('${newTrack.track_id}')">
                                üëé Nu √Æmi place
                            </button>
                        </div>
                    </div>
                `;
                
                container.insertAdjacentHTML('beforeend', newTrackHtml);
                
                // Animate the new track in
                const newTrackElement = container.lastElementChild;
                setTimeout(() => {
                    newTrackElement.style.transition = 'all 0.5s ease';
                    newTrackElement.style.opacity = '1';
                    newTrackElement.style.transform = 'translateY(0)';
                }, 100);
                
                // Refill buffer if getting low
                if (recommendationBuffer.length < 3) {
                    if (currentUser) {
                        await loadRecommendationBuffer();
                    } else {
                        await loadTestRecommendationBuffer();
                    }
                }
            } else {
                console.log('Buffer is empty, loading more recommendations...');
                // Buffer is empty, load more
                if (currentUser) {
                    await loadRecommendationBuffer();
                } else {
                    await loadTestRecommendationBuffer();
                }
                
                // Try again after loading
                if (recommendationBuffer.length > 0) {
                    await addNewTrackFromBuffer();
                }
            }
        }

        async function loadNewRecommendations() {
            console.log('üîÑ Loading new recommendations...');
            const refreshBtn = document.querySelector('.refresh-btn');
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = 'üîÑ Se √ÆncarcƒÉ...';
            
            if (currentUser) {
                await loadRecommendations(true); // Force refresh
            } else {
                await loadTestRecommendations(true); // Force refresh
            }
            
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = 'üîÑ RecomandƒÉri Noi';
        }
        
        async function showSimilarTracksNotification(likedTrackId) {
            if (!currentUser) return;
            
            try {
                // Show loading notification
                const notification = document.createElement('div');
                notification.className = 'similar-tracks-notification';
                notification.innerHTML = `
                    <div class="notification-content">
                        <div class="loading-spinner"></div>
                        <p>üéµ CƒÉutƒÉm piese similare...</p>
                    </div>
                `;
                document.body.appendChild(notification);
                
                // Get similar tracks from Recombee
                const response = await fetch(`/api/user/${currentUser.user_id}/recommendations/similar/${likedTrackId}?count=3`);
                
                if (response.ok) {
                    const data = await response.json();
                    const similarTracks = data.recommendations;
                    
                    if (similarTracks && similarTracks.length > 0) {
                        // Update notification with similar tracks
                        notification.innerHTML = `
                            <div class="notification-content">
                                <h4>üéµ Piese similare cu cea apreciatƒÉ:</h4>
                                <div class="similar-tracks-list">
                                    ${similarTracks.map(track => `
                                        <div class="similar-track-item" onclick="openSimilarTrackModal('${track.track_id}')">
                                            <strong>${track.track_name}</strong><br>
                                            <small>${track.artists}</small>
                                            <div class="track-preview">Click pentru detalii</div>
                                        </div>
                                    `).join('')}
                                </div>
                                <button onclick="this.parentElement.parentElement.remove()" class="close-notification">‚úï</button>
                            </div>
                        `;
                        
                        // Auto-hide after 10 seconds
                        setTimeout(() => {
                            if (notification.parentElement) {
                                notification.remove();
                            }
                        }, 10000);
                        
                        console.log(`üì¶ ${similarTracks.length} piese similare gƒÉsite pentru ${likedTrackId}`);
                    } else {
                        notification.innerHTML = `
                            <div class="notification-content">
                                <p>üîç Nu s-au gƒÉsit piese similare momentan</p>
                                <button onclick="this.parentElement.parentElement.remove()" class="close-notification">‚úï</button>
                            </div>
                        `;
                        setTimeout(() => notification.remove(), 3000);
                    }
                } else {
                    notification.innerHTML = `
                        <div class="notification-content">
                            <p>‚ùå Eroare la cƒÉutarea pieselor similare</p>
                            <button onclick="this.parentElement.parentElement.remove()" class="close-notification">‚úï</button>
                        </div>
                    `;
                    setTimeout(() => notification.remove(), 3000);
                }
                
            } catch (error) {
                console.error('Error getting similar tracks:', error);
            }
        }
        
        let currentModalTrack = null;
        
        async function openSimilarTrackModal(trackId) {
            if (!currentUser) return;
            
            try {
                // Ob»õine detalii complete despre piesƒÉ
                const response = await fetch(`/api/user/${currentUser.user_id}/recommendations/similar/${trackId}?count=1`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.recommendations && data.recommendations.length > 0) {
                        const track = data.recommendations[0];
                        currentModalTrack = track;
                        
                        // PopuleazƒÉ modalul cu detaliile piesei
                        const modalCard = document.getElementById('modalTrackCard');
                        modalCard.innerHTML = `
                            <div class="track-name">${track.track_name}</div>
                            <div class="track-artist">üé§ ${track.artists}</div>
                            <div class="track-details">
                                üéº Gen: ${track.track_genre || 'N/A'} | 
                                ‚ö° Energie: ${(track.energy || 0).toFixed(2)} | 
                                üíÉ Dansabilitate: ${(track.danceability || 0).toFixed(2)} | 
                                üìà Popularitate: ${track.popularity || 'N/A'}
                                <br>
                                üéµ Album: ${track.album_name || 'N/A'} |
                                ‚è±Ô∏è DuratƒÉ: ${track.duration_ms ? Math.floor(track.duration_ms / 60000) + ':' + String(Math.floor((track.duration_ms % 60000) / 1000)).padStart(2, '0') : 'N/A'}
                                <br>
                                <small style="color: #666;">SimilarƒÉ cu piesa pe care ai apreciat-o</small>
                            </div>
                            <div class="track-actions">
                                <button class="action-btn like-btn" onclick="likeModalTrack()">
                                    ‚ù§Ô∏è √émi place
                                </button>
                                <button class="action-btn dislike-btn" onclick="dislikeModalTrack()">
                                    üëé Nu √Æmi place
                                </button>
                            </div>
                        `;
                        
                        // Afi»ôeazƒÉ modalul
                        const modal = document.getElementById('similarTrackModal');
                        modal.classList.add('show');
                        
                        // Trimite view pentru tracking
                        if (track.recomm_id) {
                            sendTrackView(track.track_id, track.recomm_id);
                        }
                        
                        console.log('üéµ Modal deschis pentru:', track.track_name);
                    }
                } else {
                    console.error('Eroare la ob»õinerea detaliilor piesei');
                }
            } catch (error) {
                console.error('Error opening modal:', error);
            }
        }
        
        function closeSimilarTrackModal() {
            const modal = document.getElementById('similarTrackModal');
            const modalContent = modal.querySelector('.modal-content');
            
            // Anima»õie de √Ænchidere
            modalContent.classList.add('closing');
            
            setTimeout(() => {
                modal.classList.remove('show');
                modalContent.classList.remove('closing');
                currentModalTrack = null;
            }, 300);
        }
        
        async function likeModalTrack() {
            if (!currentModalTrack || !currentUser) return;
            
            const track = currentModalTrack;
            
            try {
                // Trimite like cƒÉtre Recombee
                const response = await fetch(`/api/user/${currentUser.user_id}/interaction`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        track_id: track.track_id,
                        interaction_type: 'like',
                        recomm_id: track.recomm_id,
                        metadata: {
                            context: 'similar_track_modal',
                            action: 'like_button'
                        }
                    })
                });
                
                if (response.ok) {
                    console.log('‚úÖ Like trimis pentru piesa similarƒÉ:', track.track_name);
                    
                    // Anima»õie de succes
                    const likeBtn = document.querySelector('.modal-track-card .like-btn');
                    likeBtn.innerHTML = '‚úÖ Apreciat!';
                    likeBtn.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
                    likeBtn.disabled = true;
                    
                    // AdaugƒÉ piesa la recomandƒÉri
                    recommendationBuffer.push(track);
                    
                    // √énchide modalul dupƒÉ 1.5 secunde
                    setTimeout(() => {
                        closeSimilarTrackModal();
                        addNewTrackFromBuffer();
                    }, 1500);
                    
                    // CautƒÉ piese similare cu aceastƒÉ piesƒÉ
                    setTimeout(() => {
                        showSimilarTracksNotification(track.track_id);
                    }, 2000);
                    
                } else {
                    console.error('Eroare la trimiterea like-ului');
                }
            } catch (error) {
                console.error('Error liking modal track:', error);
            }
        }
        
        async function dislikeModalTrack() {
            if (!currentModalTrack || !currentUser) return;
            
            const track = currentModalTrack;
            
            try {
                // Trimite dislike cƒÉtre Recombee
                const response = await fetch(`/api/user/${currentUser.user_id}/interaction`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        track_id: track.track_id,
                        interaction_type: 'dislike',
                        recomm_id: track.recomm_id,
                        metadata: {
                            context: 'similar_track_modal',
                            action: 'dislike_button'
                        }
                    })
                });
                
                if (response.ok) {
                    console.log('üëé Dislike trimis pentru piesa similarƒÉ:', track.track_name);
                    
                    // Anima»õie de feedback
                    const dislikeBtn = document.querySelector('.modal-track-card .dislike-btn');
                    dislikeBtn.innerHTML = 'üëé Respins';
                    dislikeBtn.style.background = 'linear-gradient(135deg, #f44336, #d32f2f)';
                    dislikeBtn.disabled = true;
                    
                    // √énchide modalul dupƒÉ 1 secundƒÉ
                    setTimeout(() => {
                        closeSimilarTrackModal();
                    }, 1000);
                    
                } else {
                    console.error('Eroare la trimiterea dislike-ului');
                }
            } catch (error) {
                console.error('Error disliking modal track:', error);
            }
        }
        
        // √énchide modalul cu ESC
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeSimilarTrackModal();
            }
        });
    </script>
</body>
</html>
</html>